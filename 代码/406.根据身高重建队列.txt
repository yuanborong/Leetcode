// 首先先排序，确保每个元素左边的所有元素身高都大于元素本身
// 在确保了的情况下，这个元素并非在它最合适的位置，那么就要考虑它必须进行插队
// 由于这个元素如果需要插队，那么他的k就保证了它的位置了，直接插进去那里即可

class Solution {
    public int[][] reconstructQueue(int[][] people) {

        int len = people.length;
        if(len <= 0) return people;

        Arrays.sort(people , (p1 , p2) -> {
            if(p1[0] == p2[0]) return p1[1] - p2[1];
            else{
                return p2[0] - p1[0];
            }
        });
        List<int[]> res = new ArrayList<>();
        for(int i = 0 ; i < len ; i++){
            res.add(people[i][1] , people[i]);
        }
        return (res.toArray(new int[1][1]));

    }
}