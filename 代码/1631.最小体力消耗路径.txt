class Solution {
    public int minimumEffortPath(int[][] heights) {

        int len = heights.length ;
        if(len <= 0) return 0;
        int width =heights[0].length ; 
        if(width <= 0) return 0;

        Edge[] edgeArr = new Edge[(len * (width - 1) + (width * (len - 1)))];
        int index = 0;
        for(int i = 0 ; i < len ; i++){
            for(int j = 0 ; j < width ; j++){
                if(j != width - 1){
                    edgeArr[index++] = new Edge(i * width + j , i * width + j + 1 , Math.abs(heights[i][j] - heights[i][j+1])) ;
                }
                if(i != len - 1){
                    edgeArr[index++] = new Edge(i * width + j , (i + 1) * width + j , Math.abs(heights[i][j] - heights[i+1][j])) ;
                }
            }
        }

        Arrays.sort(edgeArr , (a , b) -> {
            return a.weight - b.weight ; 
        }) ; 

        DSU dsu = new DSU(len * width) ; 

        for(Edge edge : edgeArr){
            dsu.union(edge.i , edge.j) ;
            if(dsu.connect(0 , len * width - 1)){
                return edge.weight ;
            }
        }

        return 0;

    }
}

class Edge{

    public int i ; 
    public int j ; 
    public int weight ;

    public Edge(){}

    public Edge(int i , int j , int weight){
        this.i = i ;
        this.j = j ;
        this.weight = weight ;
    }

}

class DSU{

    public int[] parents ;

    public DSU(){}

    public DSU(int n){
        this.parents = new int[n];
        for(int i = 0 ; i < n ; i++){
            parents[i] = i ;
        }
    }

    public int find(int x){
        return (x == parents[x]) ? x : (parents[x] = find(parents[x])) ;
    }

    public void union(int x , int y){
        int parentX = find(x) ;
        int parentY = find(y) ;
        if(parentX == parentY) return ;
        parents[parentX] = parentY ; 
    }

    public boolean connect(int x , int y){
        return find(x) == find(y) ;
    }

}

