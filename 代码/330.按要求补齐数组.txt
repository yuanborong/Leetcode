// 问题：原先是往已有数组中添加新的数组，保证连续达标的区间
// 解题思路：遍历已经提供的数字，假如已经实现覆盖的区间再加上一个新的数字就能扩张现有的区间长度，那就直接扩张（边界 + nums[i]）
// 如果这个新的数字直接加入进去，不能得到连续的达标区间（如当前覆盖只能到[1 , 2] ， 新的数字为100）
// 那么此时为了要连续达标，那么只好新加入一个数组中没有的数字了
// 加入一个新数字，新数字是什么最好了。贪心算法，取当前区间最右边界加入，此时扩张（保证符合规格的前提）是最优的，能扩张至（2 * 边界）
class Solution {
    public int minPatches(int[] nums, int n) {

        int len = nums.length;
        int res = 0 ; 
        int i = 0 ; 
        // right表示当前能覆盖的区间的最大值，区间[1 , right)前闭后开区间内都可以被覆盖
        // 初始化已覆盖的区间为[1 , 1)
        long right = 1 ;
        // 一直迭代直到区间右边界是大于等于条件
        while(right <= n){
            // 如果当前考虑列表的某个数字是在可覆盖的范围之内，那么表明此时区间可扩张至 right + nums[i]处
            if(i < len && nums[i] <= right){
                right += nums[i];
                i++;
            }
            // 如果当前列表的数字并不在已覆盖的区间内，而是大于右边界，那我们只能添加一个新的数字去扩张这个区间了
            // 此时添加一个当前的右边界数字是最划算的（因为要最少添加次数），这样就可以扩张至[1 , 2 * right)处了
            else{
                res++;
                right *= 2;
            }
        }
        return res;

    }
}