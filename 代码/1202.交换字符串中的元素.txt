class Solution {
    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {

        int len = s.length();
        int len_pairs = pairs.size();
        if(len_pairs == 0) return s;

        // 依据pairs构造一个DSU
        DSU dsu = new DSU(len);
        for(List<Integer> list:pairs){
            dsu.union(list.get(0) , list.get(1));
        }

        System.out.print(3);

        // 依据并查集，将同一个集合的下标弄到一块，放到一个map里面
        Map<Integer , List<Integer>> map = new HashMap<>();
        for(int i = 0 ; i < len ; i++){
            int x = dsu.find(i);
            if(map.containsKey(x) == false){
                List<Integer> new_list = new ArrayList<>();
                map.put(x , new_list);
            }
            map.get(x).add(i);
        }

        System.out.print(1);

        // 依据这个集合的map，对同一个集合的下标的元素进行排序
        StringBuilder sb = new StringBuilder(s);
        for(int key : map.keySet()){
            List<Integer> cur_union = map.get(key);
            if(cur_union.size() > 1){
                stringSort(sb , cur_union);
            }
        }

        return sb.toString();

    }

    public void stringSort(StringBuilder sb , List<Integer> union){

        int len = union.size();
        char[] arr = new char[len];
        for(int i = 0 ; i < len ; i++){
            arr[i] = sb.charAt(union.get(i));
        }
        Arrays.sort(arr);
        for(int i = 0 ; i < len ; i++){
            sb.setCharAt(union.get(i) , arr[i]);
        }
        return;

    }

    class DSU{

        public int[] parent ;

        // 初始化每个元素都属于它本身的集合
        public DSU(int len){
            this.parent = new int[len];
            for(int i = 0 ; i < len ; i++){
                this.parent[i] = i;
            }
        }

        public int find(int x){
            return parent[x] != x ? parent[x] = find(parent[x]) : x;
        }

        public void union(int x , int y){
            parent[this.find(x)] = this.find(y);
            return ;
        }

    }

}