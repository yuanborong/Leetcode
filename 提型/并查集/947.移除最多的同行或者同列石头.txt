class DSU{

    public int[] parent;

    public DSU(int len){
        this.parent = new int[len];
    }

    public int find(int x){
        return (x == parent[x]) ? x : find(parent[x]);
    }

    public void union(int x , int y){
        int parentX = find(x);
        int parentY = find(y);
        if(parentX != parentY){
            parent[parentX] = parentY ;
        }
    }
    
}

class Solution {
    public int removeStones(int[][] stones) {

        int len = stones.length;
        if(len <= 1) return 0 ;
        // parent数组前10000表示行，后10000表示列
        DSU dus = new DSU(20010);
        for(int i = 0 ; i < 20010 ; i++){
            dus.parent[i] = i;
        }
        // 将每个元素行和列合并成通过一个父亲，10001是第一列，10002是第二列
        // 将同一个结点的行和列都归在一个集合。这个过程中因为同一行都是共享同一个父亲，点与点的集合也就在这一步完成
        for(int i = 0 ; i < len ; i++){
            dus.union(stones[i][0] , stones[i][1] + 10001);
        }
        Set<Integer> set = new HashSet<>();
        for(int i = 0 ; i < len ; i++){
            set.add(dus.find(stones[i][0]));
        }
        return len - set.size();

    }
}