class Solution {
    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {

        int lenWords = words.length ;
        int lenPuzzles = puzzles.length ;
        List<Integer> res = new ArrayList<>() ;

        // 统计谜底words的二进制形式总共的数量情况
        // 如abde的二进制形式（1101100....）总共26位
        // 用字典来存储，看看相同二进制格式的（拥有相同字母的）的谜底words有多少个
        Map<Integer , Integer> states = new HashMap<>() ;
        for(int i = 0 ; i < lenWords ; i++){
            int lenWord = words[i].length() ;
            int state = 0 ;
            for(int j = 0 ; j < lenWord ;  j++){
                state = state | (1 << (words[i].charAt(j) - 'a')) ;
            }
            states.put(state , states.getOrDefault(state , 0) + 1) ;
            // System.out.println(state) ;
        }

        for(int i = 0 ; i < lenPuzzles ; i++){
            int curCount = 0 ;
            String puzzle = puzzles[i] ;
            int lenPuzzle = puzzle.length() ;
            // 首先得到这个谜面puzzle的二进制格式
            int statePuzzle = 0 ;
            for(int j = 0 ; j < lenPuzzle ; j++){
                statePuzzle = statePuzzle | (1 << (puzzle.charAt(j) - 'a')) ;
            }
            // System.out.println(statePuzzle) ;
            // 遍历这个二进制格式的子集（方式  ）
            for(int temp = statePuzzle ; temp > 0 ; temp = ((temp - 1) & statePuzzle)){
                if((temp & (1 << (puzzle.charAt(0) - 'a'))) != 0){
                    curCount += states.getOrDefault(temp , 0) ;
                    // System.out.println(222) ;
                }
            }
            res.add(curCount) ;
        }

        return res ;

    }
}